# Register Window Implementation Completion Plan

This document outlines the tasks required to complete the register window implementation for the Ferrous Lua VM. This implementation will provide proper register isolation between function calls and solve the register conflict issues.

## Core Infrastructure Tasks

- [x] Fix `allocate_window()` to return window index instead of base offset
- [x] Remove duplicate RegisterWindowSystem implementation in vm.rs
- [x] Implement basic window access and manipulation methods
- [x] Fix bracket matching issues in VM implementation
- [ ] Add proper window index validation throughout the codebase
- [ ] Implement complete window deallocation/cleanup during error handling
- [ ] Add window debugging and inspection tools
- [ ] Implement window state visualization for complex debugging scenarios
- [ ] Create comprehensive tests for window boundary conditions

## Opcode Implementation Tasks

- [x] Implement Move opcode
- [x] Implement LoadK opcode
- [x] Implement LoadBool opcode
- [x] Implement LoadNil opcode
- [x] Implement Closure opcode
- [x] Implement Call opcode
- [x] Implement Return opcode
- [x] Implement Add opcode
- [ ] Implement GetGlobal opcode (currently blocking)
- [ ] Implement SetGlobal opcode
- [ ] Implement GetUpval opcode
- [ ] Implement SetUpval opcode
- [ ] Implement GetTable opcode 
- [ ] Implement SetTable opcode
- [ ] Implement NewTable opcode
- [ ] Implement Self_ opcode
- [ ] Implement arithmetic opcodes (Sub, Mul, Div, Mod, Pow)
- [ ] Implement unary opcodes (Unm, Not, Len)
- [ ] Implement Concat opcode
- [ ] Implement comparison opcodes (Eq, Lt, Le)
- [ ] Implement test opcodes (Test, TestSet)
- [ ] Implement jump opcode (Jmp)
- [ ] Implement loop opcodes (ForPrep, ForLoop, TForLoop)
- [ ] Implement VarArg opcode
- [ ] Implement Close opcode
- [ ] Implement Eval opcode

## Integration Tasks

- [ ] Update process_function_call to properly handle register windows
- [ ] Update handle_c_function_call for full compatibility with register windows
- [ ] Modify process_metamethod_call to work with window indices
- [ ] Ensure all VM state operations respect window boundaries
- [ ] Refine ExecutionContext to work with register windows
- [ ] Integrate TForLoop with register window-aware iterator handling
- [ ] Enhance closure creation with proper upvalue binding in windowed environment

## Transaction System Enhancements

- [x] Update transaction system to respect register protection
- [ ] Implement RegisterProtectionScope RAII guards
- [ ] Add transaction validation for window index references
- [ ] Create window-aware transaction batching for multi-register operations
- [ ] Implement failure recovery for aborted window operations
- [ ] Enhance transaction commit process to maintain window consistency

## Compiler Integration

- [ ] Update the compiler's RegisterAllocator to be aware of window boundaries
- [ ] Modify register preservation mechanisms to use window protection
- [ ] Ensure proper handling of upvalues across window boundaries
- [ ] Add window-specific hints in generated bytecode for optimal register usage
- [ ] Implement better debug information linking source to windowed registers

## Testing Tasks

- [ ] Create minimal test script for each opcode implementation
- [ ] Develop stress tests for window allocation/deallocation
- [ ] Implement deep call stack tests to verify window isolation
- [ ] Create closure tests that capture variables across multiple windows
- [ ] Add performance benchmarks comparing windowed vs. non-windowed execution
- [ ] Test edge cases for maximum windows/registers
- [ ] Verify correct handling of errors during window allocation

## Documentation Tasks

- [ ] Document window indexing conventions and practices
- [ ] Create architectural diagrams showing window relationships
- [ ] Add window debugging guide for VM troubleshooting
- [ ] Document window safety patterns and best practices
- [ ] Update transaction pattern documentation for window awareness
- [ ] Create examples of correct window usage patterns

## Optimization Tasks

- [ ] Implement window recycling to reduce allocation overhead
- [ ] Add window pooling for frequently used window sizes
- [ ] Optimize register access paths with better caching
- [ ] Reduce window boundary checking overhead in hot paths
- [ ] Implement lazy window allocation for simple function calls
- [ ] Add window usage statistics for optimization analysis
- [ ] Create window pressure monitoring for memory optimization

## Critical Implementation Details

### GetGlobal Implementation (Currently Blocking)

The GetGlobal opcode is currently blocking progress and requires:
- Access to the global table through the transaction system
- Proper string constant handling for the global name
- Setting the result in the appropriate window register
- Error handling for non-existent globals

```rust
OpCode::GetGlobal => {
    // R(A) := Gbl[Kst(Bx)]
    println!("DEBUG STEP: GETGLOBAL - loading global from constant {} to R({})", instruction.bx(), a);
    
    // Get the global table
    let globals = tx.get_globals_table()?;
    
    // Get the name of the global from the constant pool
    let bx = instruction.bx() as usize;
    let name_value = {
        let closure_obj = tx.get_closure(frame.closure)?;
        if bx >= closure_obj.proto.constants.len() {
            tx.commit()?;
            return Err(LuaError::RuntimeError(format!(
                "Constant index {} out of bounds", bx
            )));
        }
        closure_obj.proto.constants[bx].clone()
    };
    
    // Get the string handle from the constant
    let name_handle = match name_value {
        Value::String(handle) => handle,
        _ => {
            tx.commit()?;
            return Err(LuaError::RuntimeError(format!(
                "Expected string constant at {}, got {}", 
                bx, name_value.type_name()
            )));
        }
    };
    
    // Get the value from the global table
    let value = tx.read_table_field(globals, &Value::String(name_handle))?;
    
    // Set the result in register A
    self.register_windows.set_register(window_idx, a, value)?;
    
    StepResult::Continue
},
```

### Window Index Consistency

Throughout all implementations, consistently follow these rules:
- Window indices are integers starting from 0 (root window)
- `CallFrame.base_register` stores the window index, not a memory address
- Use register_windows.get_register(window_idx, reg) instead of direct access
- Check window bounds before accessing registers
- Deallocate windows when function calls return

## Conclusion

Completing this register window implementation requires significant work across all layers of the VM, from the transaction system to the compiler. The tasks above represent a comprehensive plan to achieve a fully functional, robust register window system that solves the original register conflict issues while maintaining the VM's architectural principles.