# Register Window Implementation Completion Plan

This document outlines the tasks required to complete the register window implementation for the Ferrous Lua VM. This implementation provides proper register isolation between function calls and solves the register conflict issues.

## Core Infrastructure Tasks

- [x] Fix `allocate_window()` to return window index instead of base offset
- [x] Remove duplicate RegisterWindowSystem implementation in vm.rs
- [x] Implement basic window access and manipulation methods
- [x] Fix bracket matching issues in VM implementation
- [x] Add proper window index validation throughout the codebase
- [ ] Implement complete window deallocation/cleanup during error handling
- [ ] Add window debugging and inspection tools
- [ ] Implement window state visualization for complex debugging scenarios
- [x] Create comprehensive tests for window boundary conditions

## Opcode Implementation Tasks

- [x] Implement Move opcode
- [x] Implement LoadK opcode
- [x] Implement LoadBool opcode
- [x] Implement LoadNil opcode
- [x] Implement Closure opcode
- [x] Implement Call opcode
- [x] Implement Return opcode
- [x] Implement Add opcode
- [x] Implement GetGlobal opcode
- [x] Implement SetGlobal opcode
- [x] Implement GetUpval opcode
- [x] Implement SetUpval opcode
- [x] Implement GetTable opcode 
- [x] Implement SetTable opcode
- [x] Implement NewTable opcode
- [x] Implement Self_ opcode
- [x] Implement arithmetic opcodes (Sub, Mul, Div, Mod, Pow)
- [x] Implement unary opcodes (Unm, Not, Len)
- [x] Implement Concat opcode
- [x] Implement comparison opcodes (Eq, Lt, Le)
- [x] Implement test opcodes (Test, TestSet)
- [x] Implement jump opcode (Jmp)
- [x] Implement loop opcodes (ForPrep, ForLoop, TForLoop)
- [x] Implement VarArg opcode
- [x] Implement Close opcode
- [x] Implement Eval opcode

## Integration Tasks

- [x] Update process_function_call to properly handle register windows
- [x] Update handle_c_function_call for full compatibility with register windows
- [x] Modify process_metamethod_call to work with window indices
- [x] Ensure all VM state operations respect window boundaries
- [ ] Refine ExecutionContext to work with register windows
- [x] Integrate TForLoop with register window-aware iterator handling
- [x] Enhance closure creation with proper upvalue binding in windowed environment

## Transaction System Enhancements

- [x] Update transaction system to respect register protection
- [ ] Implement RegisterProtectionScope RAII guards
- [x] Add transaction validation for window index references
- [x] Create window-aware transaction batching for multi-register operations
- [ ] Implement failure recovery for aborted window operations
- [x] Enhance transaction commit process to maintain window consistency

## Compiler Integration

- [x] Update the compiler's RegisterAllocator to be aware of window boundaries
- [x] Modify register preservation mechanisms to use window protection
- [x] Ensure proper handling of upvalues across window boundaries
- [ ] Add window-specific hints in generated bytecode for optimal register usage
- [ ] Implement better debug information linking source to windowed registers

## Testing Tasks

- [x] Create minimal test script for each opcode implementation
- [ ] Develop stress tests for window allocation/deallocation
- [x] Implement deep call stack tests to verify window isolation
- [x] Create closure tests that capture variables across multiple windows
- [ ] Add performance benchmarks comparing windowed vs. non-windowed execution
- [ ] Test edge cases for maximum windows/registers
- [ ] Verify correct handling of errors during window allocation

## Documentation Tasks

- [x] Document window indexing conventions and practices
- [ ] Create architectural diagrams showing window relationships
- [ ] Add window debugging guide for VM troubleshooting
- [x] Document window safety patterns and best practices
- [x] Update transaction pattern documentation for window awareness
- [ ] Create examples of correct window usage patterns

## Optimization Tasks

- [ ] Implement window recycling to reduce allocation overhead
- [ ] Add window pooling for frequently used window sizes
- [ ] Optimize register access paths with better caching
- [ ] Reduce window boundary checking overhead in hot paths
- [ ] Implement lazy window allocation for simple function calls
- [ ] Add window usage statistics for optimization analysis
- [ ] Create window pressure monitoring for memory optimization

## Key Implementation Learnings

### Borrow Checker Challenges and Solutions

1. **Extraction Before Usage**: Always extract all data you need from the transaction as owned values *before* any further transaction operations. This avoids borrow checker conflicts.

2. **Phase Separation**: Use complete phase separation when implementing opcodes, ensuring that borrows don't overlap. Extract data in phase 1, then operate on it in phase 2 without holding references.

3. **No Self-Reference**: Avoid calling methods that borrow `self` while already holding a borrow of `self.heap` through a transaction. Instead, use standalone helper functions.

4. **Transaction Lifecycle**: Do not commit transactions early in opcodes unless absolutely necessary. Let the `step()` method handle the transaction lifecycle.

5. **Window-Stack Sync**: Register windows and thread stacks must be kept in sync for upvalue capture. Use `sync_window_to_stack_helper()` to ensure values are properly available.

### Upvalue Implementation

Proper upvalue implementation requires:

1. Calculating absolute stack positions from window indices (typically `window_idx * 256 + register_idx`)
2. Syncing window values to the thread stack before upvalue creation 
3. Creating open upvalues that point to the thread stack position
4. Reading values from the thread stack when accessing upvalues

### Transaction Commit Management

For opcodes that need early transaction commits:
1. Handle all error paths with `tx.commit()?` before returning errors
2. Set `should_increment_pc = false` if you've already incremented the PC
3. Ensure all borrows of transaction-provided data are dropped before committing

### Register Window Invariants

1. Windows are views into the thread's stack
2. Base register in call frames stores the window INDEX (not a memory address)
3. Always access registers through the window system, not directly
4. Protect registers that must not be modified during complex operations